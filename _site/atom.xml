<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Prakash Natarajan</title>
 <link href="http://www.prakashn.com/atom.xml" rel="self"/>
 <link href="http://www.prakashn.com/"/>
 <updated>2015-03-13T17:56:34-04:00</updated>
 <id>http://www.prakashn.com</id>
 <author>
   <name>Prakash Natarajan</name>
   <email></email>
 </author>

 
 <entry>
   <title>Stock Market Volatility with Mapreduce</title>
   <link href="http://www.prakashn.com/2015/02/28/Stock-Market-Volatility/"/>
   <updated>2015-02-28T00:00:00-05:00</updated>
   <id>http://www.prakashn.com/2015/02/28/Stock-Market-Volatility</id>
   <content type="html">&lt;p&gt;Using mapreduce to compute the stock market volatility of 3000 stocks with their past three year data.
* &lt;a href=&quot;https://github.com/prakashn27/Volatility-Analysis&quot;&gt;Code repo Link&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Algorithm&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Technology&lt;/strong&gt;  : Java&lt;br&gt;
&lt;strong&gt;Paradigm&lt;/strong&gt;    : MapReduce with Hadoop&lt;/p&gt;

&lt;h3&gt;Objective:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt; Find the top 10 stocks with Lowest (min) volatility.&lt;/li&gt;
&lt;li&gt; Find the top 10 stocks with the Highest (max) volatility.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Algorithm&lt;/h3&gt;

&lt;p&gt;I used mapreduce paradigm of Hadoop to serialise the calculation of volatility for each month and computed the top 10 and bottom values.&lt;br&gt;
Number of Mapper Implementation : 3 Number of Reducer Implementation : 3        &lt;/p&gt;

&lt;h4&gt;Roles of each Mapper and Reducer:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Mapper1&lt;/strong&gt;&lt;br&gt;
• splits the input data and options the date and close adjacent value.
• key - stock_name + month + year
• value - date + adjacent close value&lt;br&gt;
&lt;strong&gt;Reducer1&lt;/strong&gt;&lt;br&gt;
• Since after the map step the values which have same key are grouped
together and passed to the reducer as iterable, values that correspond to specific month and year of the particular stock are grouped together.
• Beginning adjacent close value and end adjacent close value are obtained by integrating through the iterable and the value of xi for the corresponding month is computed.
• key - Company Name
• Value - Computed Xi.&lt;br&gt;
&lt;strong&gt;Mapper2&lt;/strong&gt;&lt;br&gt;
• Now we have to consolidate all the values obtained from the reducer with respect to company name.
• Key - Company Name
• Value - Xi&lt;br&gt;
&lt;strong&gt;Reducer2&lt;/strong&gt;&lt;br&gt;
• All the xi corresponding to the the respective companies are grouped
together.
• Volatility for the particular company is obtained from these values.
• Key - Company Name
• Value - Volatility&lt;br&gt;
&lt;strong&gt;Mapper3:&lt;/strong&gt;&lt;br&gt;
• All the companies are grouped together with a common key.
• Key - Common
• Value = Company Name + Volatility
&lt;strong&gt;Reducer3:&lt;/strong&gt;&lt;br&gt;
• Obtained iterable contains all the company name with values and they are
sorted by a custom comparator.
• top 10 and bottom 10 values are obtained from the List&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>My tweaks of PintOS Operating System!</title>
   <link href="http://www.prakashn.com/2014/09/06/my-tweaks-of-an-OS/"/>
   <updated>2014-09-06T00:00:00-04:00</updated>
   <id>http://www.prakashn.com/2014/09/06/my-tweaks-of-an-OS</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://web.stanford.edu/class/cs140/projects/pintos/pintos.html#SEC_Contents&quot;&gt;Pintos&lt;/a&gt; is a simple operating system framework for the 80x86 architecture. It does not support priority scheduling. Our task is to implement priority scheduler and multilevel feed back priority scheduler.&lt;br&gt;
* &lt;a href=&quot;https://github.com/prakashn27/Pintos-Project1&quot;&gt;Code repo Link&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Algorithm&lt;/h2&gt;

&lt;h3&gt;Priority Scheduler&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For priority scheduler, Changed the scheduler linked list into priority queue, so that everytime next Highest prioirty thread is scheduled.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt; 
1. Guarantees early completion of high priority jobs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt;&lt;br&gt;
- Can cause starvation of low priority jobs 
- How to decide/assign priority numbers?&lt;/p&gt;

&lt;h3&gt;Multi level feedback priority queue scheduler&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For Multilevel feedback queue scheduler, I maintained seperate queue (8ms round robin queue, 16ms round robin queue and FIFO). All the process first goes into the first queue, if it is not completed then it is scheduled to next queue and even if 24ms (8 + 16) is not enough for the process to finish it is appended in the tail of the FIFO. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt;&lt;br&gt;
1. Great for timesharing – no starvation
2. Does not require prior knowledge of CPU burst times
3. Generally reduces average response time&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt;&lt;br&gt;
1. What if all jobs are almost time same length? Increases the turnaround time.&lt;br&gt;
2. How to set the “best” time quantum?
        * if small, then context switch often, incurring high overhead&lt;br&gt;
        * if large, then response time degrades             &lt;/p&gt;
</content>
 </entry>
 

</feed>
